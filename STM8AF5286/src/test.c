//test
#include "main.h"
#include "stm8s.h"

extern u16 T1[100]; // таблица по которой ищем
extern u8 NT1;
extern u16 T2[100]; // таблица значений которых нет в Т1 - для несовпадений

/////////////////
u8 NT1 = 100; //длина таблицы для функции поиска
///////////////////////////////////////////////////////
/// классичечкий двоичный поиск
u8 b_f(u16 A)  // A - что ищем по таблице T1  длиной NT1 
{
u8 m, left, right;
left = (u8)0; right = (u8)(NT1-1);
while (1)
 {
    if (left > right) return (0xff); // значение не найдено
    m = (u8)(left + (right - left) / 2);
    if (T1[m] < A) left  =  (u8)(m + 1);
    if (T1[m] > A) right =  (u8)(m - 1);
    if (T1[m] == A) return m;
 }
}

//тест первый, уменьшаем число if
u8 b_f1(u16 A)  // A - что ищем по таблице T1  длиной NT1 
{
u8 m, left, right;
left = (u8)0; right = (u8)(NT1-1);
while (1)
 {
    if (left > right) return (0xff); // значение не найдено
    m = (u8)(left + (right - left) / 2);
    if (T1[m] == A) return m;
		if(T1[m] < A) 
		{
		 left  =  (u8)(m + 1);
		}
		else
		{
		 right =  (u8)(m - 1);
		}
 }
}

//тест второй, уменьшение обращений к индексированным переменным
u8 b_f2(u16 A)  // A - что ищем по таблице T1  длиной NT1 
{
u8 m, left, right;
u16 r;
left = (u8)0; right = (u8)(NT1-1);
while (1)
 {
    if (left > right) return (0xff); // значение не найдено
    m = (u8)(left + (right - left) / 2);
		r = T1[m];
    if (T1[m] == A) return m;
		if(T1[m] < A) 
		{
		 left  =  (u8)(m + 1);
		}
		else
		{
		 right =  (u8)(m - 1);
		}
 }
}

u8 m, left, right;
u16 r;
//тест третий, объявим переменные глобальными
u8 b_f3(u16 A)  // A - что ищем по таблице T1  длиной NT1 
{
//u8 m, left, right;
//u16 r;
left = (u8)0; right = (u8)(NT1-1);
while(1)
 {
    if (left > right) return (0xff); // значение не найдено
    m = (u8)(left + (right - left) / 2);
		r = T1[m];
    if (T1[m] == A) return m;
		if(T1[m] < A) 
		{
		 left  =  (u8)(m + 1);
		}
		else
		{
		 right =  (u8)(m - 1);
		}
 }
}

u8 P_f(u16 A)//последовательный поиск  
{
  u8 m;
	for(m=0;m<NT1;m++)
	{
	if (T1[m] == A) return m;
	}
	return (0xff);
}

u8 NNT=3;// или больше?? Это размер последнего куска деления, когда на последовательный переходим

u8 bp_f4(u16 A)  // гибрид бинарного и последовательного  
{
u8 m, left, right;
u16 r;
left = (u8)0; right = (u8)(NT1-1);
while (1)
{
  //   if (left > right) return (0xff); 
  // вместо деления до победного конца – остановится раньше
  // и перейти к последовательному поиску
   if (right - left < NNT)
    {
    for(m= left ;m<= right;m++)
		{
      if (T1[m]  == A) return m;
		}
      return (0xff);
      
    }// конец посл поиска и программы

//
    m = (u8)(left + (right - left) / 2);
    
    r=T1[m];  
    if (r == A) return m;
    if (r < A) left  =  (u8)(m + 1);
    else right =  (u8)(m - 1);
}
}



////  таблицы  ///// /////////////////// //////////// 
u16 T1[100] = {		
245	,	
1556	,	
2994	,	
3534	,	
3710	,	
3798	,	
4150	,	
4893	,	
5218	,	
5279	,	
5329	,	
5415	,	
5464	,	
7963	,	
8216	,	
8312	,	
10734	,	
11667	,	
11908	,	
13779	,	
14201	,	
14366	,	
14477	,	
14648	,	
14922	,	
15234	,	
19782	,	
20234	,	
20903	,	
21028	,	
21033	,	
21440	,	
21991	,	
22743	,	
23061	,	
23730	,	
25452	,	
25469	,	
25637	,	
25905	,	
26018	,	
26091	,	
26282	,	
28329	,	
32814	,	
33093	,	
34133	,	
35177	,	
35308	,	
35482	,	
36152	,	
36573	,	
38993	,	
39245	,	
39679	,	
40311	,	
40398	,	
42029	,	
43245	,	
43265	,	
43312	,	
43598	,	
44093	,	
45169	,	
45534	,	
45541	,	
45804	,	
46472	,	
46779	,	
47510	,	
48564	,	
48641	,	
50139	,	
50463	,	
50711	,	
50734	,	
50753	,	
51096	,	
51301	,	
51774	,	
52924	,	
53011	,	
53561	,	
53762	,	
54071	,	
54261	,	
56747	,	
57312	,	
57616	,	
58074	,	
58500	,	
59556	,	
59827	,	
60003	,	
60152	,	
60855	,	
61226	,	
61318	,	
64216	,	
64947	};	
//////////////////////////////////////////		
		
u16 T2[100]={		
	901	
,	2275	
,	3264	
,	3622	
,	3754	
,	3974	
,	4522	
,	5056	
,	5249	
,	5304	
,	5372	
,	5440	
,	6714	
,	8090	
,	8264	
,	9523	
,	11201	
,	11788	
,	12844	
,	13990	
,	14284	
,	14422	
,	14563	
,	14785	
,	15078	
,	17508	
,	20008	
,	20569	
,	20966	
,	21031	
,	21237	
,	21716	
,	22367	
,	22902	
,	23396	
,	24591	
,	25461	
,	25553	
,	25771	
,	25962	
,	26055	
,	26187	
,	27306	
,	30572	
,	32954	
,	33613	
,	34655	
,	35243	
,	35395	
,	35817	
,	36363	
,	37783	
,	39119	
,	39462	
,	39995	
,	40355	
,	41214	
,	42637	
,	43255	
,	43289	
,	43455	
,	43846	
,	44631	
,	45352	
,	45538	
,	45673	
,	46138	
,	46626	
,	47145	
,	48037	
,	48603	
,	49390	
,	50301	
,	50587	
,	50723	
,	50744	
,	50925	
,	51199	
,	51538	
,	52349	
,	52968	
,	53286	
,	53662	
,	53917	
,	54166	
,	55504	
,	57030	
,	57464	
,	57845	
,	58287	
,	59028	
,	59692	
,	59915	
,	60078	
,	60504	
,	61041	
,	61272	
,	62767	
,	64582	
,	64972	};
